#!/usr/bin/env bash
#
# üêï Retriever - Fetches your repos like a good dog
#
# Clone, sync, and rebase all your GitHub repos with one command.
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default repos directory
REPOS_DIR="${RETRIEVER_REPOS_DIR:-$HOME/repos}"

usage() {
    cat <<EOF
üêï Retriever - Fetches your repos like a good dog

Usage: retriever [command] [options]

Commands:
    clone       Select and clone repos from GitHub
    fetch       Fetch and rebase selected repos
    list        List all repos in the repos directory
    install     Add retriever to your PATH
    help        Show this help message

Options:
    -d, --dir DIR    Directory to store repos (default: \$RETRIEVER_REPOS_DIR or ~/repos)

Environment:
    RETRIEVER_REPOS_DIR    Default directory for repos

Examples:
    retriever clone                  # Select repos to clone
    retriever fetch                  # Fetch and rebase all repos
    retriever clone -d ~/projects    # Clone to specific directory
EOF
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

check_dependencies() {
    local missing=()

    if ! command -v gh &> /dev/null; then
        missing+=("gh (GitHub CLI)")
    fi

    if ! command -v fzf &> /dev/null; then
        missing+=("fzf (fuzzy finder)")
    fi

    if ! command -v git &> /dev/null; then
        missing+=("git")
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        log_error "Missing dependencies:"
        for dep in "${missing[@]}"; do
            echo "  - $dep"
        done
        echo ""
        echo "Install with:"
        echo "  brew install gh fzf git"
        exit 1
    fi

    # Check gh auth
    if ! gh auth status &> /dev/null; then
        log_error "Not authenticated with GitHub CLI"
        echo "Run: gh auth login"
        exit 1
    fi
}

clone_repos() {
    check_dependencies

    # Create repos directory
    mkdir -p "$REPOS_DIR"

    log_info "Fetching your repos from GitHub..."

    # Get list of repos with name and description
    local all_repos
    all_repos=$(gh repo list --limit 200 --json nameWithOwner,description \
        --jq '.[] | "\(.nameWithOwner)\t\(.description // "No description")"')

    if [ -z "$all_repos" ]; then
        log_error "No repos found"
        exit 1
    fi

    # Get list of existing local repos
    local existing_repos=()
    if [ -d "$REPOS_DIR" ]; then
        for dir in "$REPOS_DIR"/*/; do
            [ -d "$dir" ] || continue
            existing_repos+=("$(basename "$dir")")
        done
    fi

    # Filter to only show repos NOT already cloned
    local new_repos=""
    while IFS= read -r line; do
        local repo_name
        repo_name=$(basename "$(echo "$line" | cut -f1)")
        local is_existing=false
        for existing in "${existing_repos[@]}"; do
            if [ "$existing" = "$repo_name" ]; then
                is_existing=true
                break
            fi
        done
        if [ "$is_existing" = false ]; then
            if [ -z "$new_repos" ]; then
                new_repos="$line"
            else
                new_repos="$new_repos"$'\n'"$line"
            fi
        fi
    done <<< "$all_repos"

    local cloned=0
    local removed=0

    # PHASE 1: Select new repos to clone
    if [ -n "$new_repos" ]; then
        log_info "Phase 1: Select NEW repos to clone (TAB to select, ENTER to confirm, ESC to skip):"
        echo ""

        local selected_new
        selected_new=$(echo "$new_repos" | fzf --multi \
            --header "üêï Select NEW repos to clone (TAB=select, ENTER=confirm, ESC=skip)" \
            --preview "echo {} | cut -f2" \
            --preview-window=down:1:wrap \
            --delimiter=$'\t' \
            --with-nth=1 \
            --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
            || true)

        if [ -n "$selected_new" ]; then
            echo ""
            log_info "Cloning selected repos to $REPOS_DIR..."
            echo ""

            while IFS= read -r line; do
                local repo_full
                repo_full=$(echo "$line" | cut -f1)
                local repo_name
                repo_name=$(basename "$repo_full")
                local target_dir="$REPOS_DIR/$repo_name"

                log_info "Cloning $repo_full..."
                if gh repo clone "$repo_full" "$target_dir" -- --quiet 2>/dev/null; then
                    log_success "Cloned $repo_name"
                    ((cloned++))
                else
                    log_error "Failed to clone $repo_name"
                fi
            done <<< "$selected_new"
        else
            log_info "No new repos selected to clone"
        fi
    else
        log_info "No new repos available to clone (all already exist locally)"
    fi

    # PHASE 2: Select existing repos to remove
    if [ ${#existing_repos[@]} -gt 0 ]; then
        echo ""
        log_info "Phase 2: Select EXISTING repos to remove (TAB to select, ENTER to confirm, ESC to skip):"
        echo ""

        # Build list of existing repos with their status
        local existing_list=""
        for repo_name in "${existing_repos[@]}"; do
            local dir="$REPOS_DIR/$repo_name"
            local status="clean"
            if [ -d "$dir/.git" ]; then
                cd "$dir"
                if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                    status="modified"
                fi
            fi
            if [ -z "$existing_list" ]; then
                existing_list="$repo_name\t$status"
            else
                existing_list="$existing_list"$'\n'"$repo_name\t$status"
            fi
        done

        local selected_remove
        selected_remove=$(echo -e "$existing_list" | fzf --multi \
            --header "üóëÔ∏è  Select repos to REMOVE (TAB=select, ENTER=confirm, ESC=skip)" \
            --preview "echo 'Status: '\$(echo {} | cut -f2)" \
            --preview-window=down:1:wrap \
            --delimiter=$'\t' \
            --with-nth=1 \
            --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
            || true)

        if [ -n "$selected_remove" ]; then
            echo ""
            log_warn "About to remove the following repos:"
            while IFS= read -r line; do
                local repo_name
                repo_name=$(echo "$line" | cut -f1)
                echo "  - $repo_name"
            done <<< "$selected_remove"

            echo ""
            read -p "Are you sure? (y/N) " -n 1 -r
            echo ""

            if [[ $REPLY =~ ^[Yy]$ ]]; then
                while IFS= read -r line; do
                    local repo_name
                    repo_name=$(echo "$line" | cut -f1)
                    local target_dir="$REPOS_DIR/$repo_name"

                    log_info "Removing $repo_name..."
                    if rm -rf "$target_dir"; then
                        log_success "Removed $repo_name"
                        ((removed++))
                    else
                        log_error "Failed to remove $repo_name"
                    fi
                done <<< "$selected_remove"
            else
                log_info "Removal cancelled"
            fi
        else
            log_info "No repos selected to remove"
        fi
    fi

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    log_success "Done! Cloned $cloned repos, removed $removed repos"
}

fetch_repos() {
    check_dependencies

    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    # Build list of repos with their status for fzf
    log_info "Scanning repos in $REPOS_DIR..."

    local repo_list=""
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue
        local repo_name
        repo_name=$(basename "$dir")

        if [ ! -d "$dir/.git" ]; then
            continue  # Skip non-git directories
        fi

        cd "$dir"
        local branch
        branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")
        local status="clean"

        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            status="modified"
        fi

        if [ -z "$repo_list" ]; then
            repo_list="$repo_name\t[$branch] ($status)"
        else
            repo_list="$repo_list"$'\n'"$repo_name\t[$branch] ($status)"
        fi
    done

    if [ -z "$repo_list" ]; then
        log_error "No git repos found in $REPOS_DIR"
        exit 1
    fi

    log_info "Select repos to fetch and rebase (TAB to select, ENTER to confirm):"
    echo ""

    local selected
    selected=$(echo -e "$repo_list" | fzf --multi \
        --header "üêï Select repos to fetch (TAB=select, Ctrl-A=all, ENTER=confirm)" \
        --preview "echo {} | cut -f2" \
        --preview-window=down:1:wrap \
        --delimiter=$'\t' \
        --with-nth=1 \
        --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
        || true)

    if [ -z "$selected" ]; then
        log_warn "No repos selected"
        exit 0
    fi

    echo ""
    log_info "Fetching and rebasing selected repos..."
    echo ""

    local success=0
    local conflicts=0
    local skipped=0
    local failed=0
    local conflict_repos=()

    while IFS= read -r line; do
        local repo_name
        repo_name=$(echo "$line" | cut -f1)
        local dir="$REPOS_DIR/$repo_name"

        cd "$dir"

        # Get current branch
        local branch
        branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

        if [ -z "$branch" ]; then
            log_warn "Skipping $repo_name (detached HEAD)"
            ((skipped++))
            continue
        fi

        # Check for uncommitted changes
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            log_warn "Skipping $repo_name (uncommitted changes)"
            ((skipped++))
            continue
        fi

        # Fetch from origin
        echo -n "Fetching $repo_name... "
        if ! git fetch origin --quiet 2>/dev/null; then
            echo ""
            log_error "Failed to fetch $repo_name"
            ((failed++))
            continue
        fi

        # Check if we need to rebase
        local upstream="origin/$branch"
        if ! git rev-parse "$upstream" &>/dev/null; then
            echo "no upstream"
            ((skipped++))
            continue
        fi

        local local_commit
        local_commit=$(git rev-parse HEAD)
        local remote_commit
        remote_commit=$(git rev-parse "$upstream")

        if [ "$local_commit" = "$remote_commit" ]; then
            echo "up to date"
            ((success++))
            continue
        fi

        # Check if we can fast-forward (no local commits ahead)
        local base
        base=$(git merge-base HEAD "$upstream")

        if [ "$base" = "$local_commit" ]; then
            # Fast-forward possible
            if git rebase "$upstream" --quiet 2>/dev/null; then
                echo "rebased (fast-forward)"
                ((success++))
            else
                echo ""
                log_error "Rebase failed for $repo_name"
                git rebase --abort 2>/dev/null || true
                ((failed++))
            fi
        else
            # Need to rebase with local changes
            echo -n "rebasing... "
            if git rebase "$upstream" --quiet 2>/dev/null; then
                echo "done"
                ((success++))
            else
                echo "conflict!"
                git rebase --abort 2>/dev/null || true
                conflict_repos+=("$repo_name")
                ((conflicts++))
            fi
        fi
    done <<< "$selected"

    cd "$REPOS_DIR"

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    log_info "Summary:"
    echo "  ‚úì Success:   $success"
    echo "  ‚ö† Skipped:   $skipped"
    echo "  ‚úó Failed:    $failed"
    echo "  ‚ö° Conflicts: $conflicts"

    if [ ${#conflict_repos[@]} -gt 0 ]; then
        echo ""
        log_warn "Repos with conflicts (need manual rebase):"
        for repo in "${conflict_repos[@]}"; do
            echo "  - $repo"
        done
    fi
}

list_repos() {
    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    log_info "Repos in $REPOS_DIR:"
    echo ""

    local count=0
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue
        local repo_name
        repo_name=$(basename "$dir")

        if [ -d "$dir/.git" ]; then
            cd "$dir"
            local branch
            branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")
            local status=""

            if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                status=" ${YELLOW}(modified)${NC}"
            fi

            echo -e "  $repo_name ${BLUE}[$branch]${NC}$status"
            ((count++))
        else
            echo -e "  $repo_name ${RED}(not a git repo)${NC}"
        fi
    done

    echo ""
    log_info "Total: $count repos"
}

install_retriever() {
    # Get the directory where this script lives
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Detect shell
    local shell_name
    shell_name=$(basename "$SHELL")
    local rc_file

    case "$shell_name" in
        zsh)
            rc_file="$HOME/.zshrc"
            ;;
        bash)
            if [ -f "$HOME/.bash_profile" ]; then
                rc_file="$HOME/.bash_profile"
            else
                rc_file="$HOME/.bashrc"
            fi
            ;;
        *)
            log_error "Unsupported shell: $shell_name"
            echo "Please manually add this to your shell config:"
            echo "  export PATH=\"\$PATH:$script_dir\""
            exit 1
            ;;
    esac

    # Check if already in PATH
    if echo "$PATH" | tr ':' '\n' | grep -qx "$script_dir"; then
        log_success "Retriever is already in your PATH"
        return 0
    fi

    # Check if export line already exists in rc file
    local export_line="export PATH=\"\$PATH:$script_dir\""
    if grep -qF "$script_dir" "$rc_file" 2>/dev/null; then
        log_success "PATH export already exists in $rc_file"
        log_info "Run 'source $rc_file' or restart your terminal"
        return 0
    fi

    # Add to rc file
    log_info "Adding retriever to PATH in $rc_file..."

    {
        echo ""
        echo "# Retriever - repo fetcher üêï"
        echo "$export_line"
    } >> "$rc_file"

    log_success "Added to $rc_file"
    echo ""
    log_info "Run this to use immediately:"
    echo "  source $rc_file"
    echo ""
    log_info "Or restart your terminal"
}

# Parse arguments
COMMAND=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--dir)
            REPOS_DIR="$2"
            shift 2
            ;;
        clone|fetch|list|install|help)
            COMMAND="$1"
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Default to help if no command
if [ -z "$COMMAND" ]; then
    usage
    exit 0
fi

# Run command
case $COMMAND in
    clone)
        clone_repos
        ;;
    fetch)
        fetch_repos
        ;;
    list)
        list_repos
        ;;
    install)
        install_retriever
        ;;
    help)
        usage
        ;;
esac
