#!/usr/bin/env bash
#
# üêï Retriever - Fetches your repos like a good dog
#
# Clone, sync, and rebase all your GitHub repos with one command.
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default repos directory
REPOS_DIR="${RETRIEVER_REPOS_DIR:-$HOME/repos}"

usage() {
    cat <<EOF
üêï Retriever - Fetches your repos like a good dog

Usage: retriever [command] [options]

Commands:
    clone               Select and clone repos from GitHub
    fetch               Fetch and rebase selected repos
    list                List all repos in the repos directory
    worktree [subcmd]   Manage git worktrees
        list            List all worktrees (default)
        add             Create a new worktree
        remove          Remove worktrees
    install             Add retriever to your PATH
    help                Show this help message

Options:
    -d, --dir DIR    Directory to store repos (default: \$RETRIEVER_REPOS_DIR or ~/repos)

Environment:
    RETRIEVER_REPOS_DIR    Default directory for repos

Examples:
    retriever clone                  # Select repos to clone
    retriever fetch                  # Fetch and rebase all repos
    retriever clone -d ~/projects    # Clone to specific directory
    retriever worktree add           # Create a new worktree
    retriever worktree list          # List all worktrees
EOF
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

check_dependencies() {
    local missing=()

    if ! command -v gh &> /dev/null; then
        missing+=("gh (GitHub CLI)")
    fi

    if ! command -v fzf &> /dev/null; then
        missing+=("fzf (fuzzy finder)")
    fi

    if ! command -v git &> /dev/null; then
        missing+=("git")
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        log_error "Missing dependencies:"
        for dep in "${missing[@]}"; do
            echo "  - $dep"
        done
        echo ""
        echo "Install with:"
        echo "  brew install gh fzf git"
        exit 1
    fi

    # Check gh auth
    if ! gh auth status &> /dev/null; then
        log_error "Not authenticated with GitHub CLI"
        echo "Run: gh auth login"
        exit 1
    fi
}

# Check if a directory is a git repository (handles both normal repos and worktrees)
is_git_repo() {
    local dir="$1"
    git -C "$dir" rev-parse --is-inside-work-tree &>/dev/null
}

# Get the type of git working directory: "main", "worktree", or "none"
get_worktree_type() {
    local dir="$1"
    if [ -d "$dir/.git" ]; then
        echo "main"
    elif [ -f "$dir/.git" ]; then
        echo "worktree"
    else
        echo "none"
    fi
}

# Get the common git directory (shared by all worktrees of a repo)
get_git_common_dir() {
    local dir="$1"
    git -C "$dir" rev-parse --git-common-dir 2>/dev/null
}

clone_repos() {
    check_dependencies

    # Create repos directory
    mkdir -p "$REPOS_DIR"

    log_info "Fetching your repos from GitHub..."

    # Get list of repos with name and description
    local all_repos
    all_repos=$(gh repo list --limit 200 --json nameWithOwner,description \
        --jq '.[] | "\(.nameWithOwner)\t\(.description // "No description")"')

    if [ -z "$all_repos" ]; then
        log_error "No repos found"
        exit 1
    fi

    # Get list of existing local repos
    local existing_repos=()
    if [ -d "$REPOS_DIR" ]; then
        for dir in "$REPOS_DIR"/*/; do
            [ -d "$dir" ] || continue
            existing_repos+=("$(basename "$dir")")
        done
    fi

    # Filter to only show repos NOT already cloned
    local new_repos=""
    while IFS= read -r line; do
        local repo_name
        repo_name=$(basename "$(echo "$line" | cut -f1)")
        local is_existing=false
        for existing in "${existing_repos[@]+"${existing_repos[@]}"}"; do
            if [ "$existing" = "$repo_name" ]; then
                is_existing=true
                break
            fi
        done
        if [ "$is_existing" = false ]; then
            if [ -z "$new_repos" ]; then
                new_repos="$line"
            else
                new_repos="$new_repos"$'\n'"$line"
            fi
        fi
    done <<< "$all_repos"

    local cloned=0
    local removed=0

    # PHASE 1: Select new repos to clone
    if [ -n "$new_repos" ]; then
        log_info "Phase 1: Select NEW repos to clone (TAB to select, ENTER to confirm, ESC to skip):"
        echo ""

        local selected_new
        selected_new=$(echo "$new_repos" | fzf --multi \
            --header "üêï Select NEW repos to clone (TAB=select, ENTER=confirm, ESC=skip)" \
            --preview "echo {} | cut -f2" \
            --preview-window=down:1:wrap \
            --delimiter=$'\t' \
            --with-nth=1 \
            --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
            || true)

        if [ -n "$selected_new" ]; then
            echo ""
            echo "DEBUG: selected_new contains $(echo "$selected_new" | wc -l | tr -d ' ') lines:"
            echo "$selected_new" | nl
            echo "DEBUG: end"
            echo ""
            log_info "Cloning selected repos to $REPOS_DIR..."
            echo ""

            while IFS= read -r line || [ -n "$line" ]; do
                echo "DEBUG: loop iteration, line='$line'"
                [ -n "$line" ] || continue
                local repo_full
                repo_full=$(echo "$line" | cut -f1)
                local repo_name
                repo_name=$(basename "$repo_full")
                local target_dir="$REPOS_DIR/$repo_name"

                log_info "Cloning $repo_full..."
                if (gh repo clone "$repo_full" "$target_dir" -- --quiet 2>/dev/null) </dev/null; then
                    log_success "Cloned $repo_name"
                    ((cloned++))
                else
                    log_error "Failed to clone $repo_name"
                fi
            done <<< "$selected_new"
        else
            log_info "No new repos selected to clone"
        fi
    else
        log_info "No new repos available to clone (all already exist locally)"
    fi

    # PHASE 2: Select existing repos to remove
    if [ ${#existing_repos[@]} -gt 0 ]; then
        echo ""
        log_info "Phase 2: Select EXISTING repos to remove (TAB to select, ENTER to confirm, ESC to skip):"
        echo ""

        # Build list of existing repos with their status
        local existing_list=""
        for repo_name in "${existing_repos[@]}"; do
            local dir="$REPOS_DIR/$repo_name"
            local status="clean"
            if is_git_repo "$dir"; then
                cd "$dir"
                if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                    status="modified"
                fi
            fi
            if [ -z "$existing_list" ]; then
                existing_list="$repo_name\t$status"
            else
                existing_list="$existing_list"$'\n'"$repo_name\t$status"
            fi
        done

        local selected_remove
        selected_remove=$(echo -e "$existing_list" | fzf --multi \
            --header "üóëÔ∏è  Select repos to REMOVE (TAB=select, ENTER=confirm, ESC=skip)" \
            --preview "echo 'Status: '\$(echo {} | cut -f2)" \
            --preview-window=down:1:wrap \
            --delimiter=$'\t' \
            --with-nth=1 \
            --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
            || true)

        if [ -n "$selected_remove" ]; then
            echo ""
            log_warn "About to remove the following repos:"
            while IFS= read -r line || [ -n "$line" ]; do
                [ -n "$line" ] || continue
                local repo_name
                repo_name=$(echo "$line" | cut -f1)
                echo "  - $repo_name"
            done <<< "$selected_remove"

            echo ""
            read -p "Are you sure? (y/N) " -n 1 -r
            echo ""

            if [[ $REPLY =~ ^[Yy]$ ]]; then
                while IFS= read -r line || [ -n "$line" ]; do
                    [ -n "$line" ] || continue
                    local repo_name
                    repo_name=$(echo "$line" | cut -f1)
                    local target_dir="$REPOS_DIR/$repo_name"

                    log_info "Removing $repo_name..."
                    if rm -rf "$target_dir"; then
                        log_success "Removed $repo_name"
                        ((removed++))
                    else
                        log_error "Failed to remove $repo_name"
                    fi
                done <<< "$selected_remove"
            else
                log_info "Removal cancelled"
            fi
        else
            log_info "No repos selected to remove"
        fi
    fi

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    log_success "Done! Cloned $cloned repos, removed $removed repos"
}

fetch_repos() {
    check_dependencies

    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    # Build list of repos with their status for fzf
    log_info "Scanning repos in $REPOS_DIR..."

    local repo_list=""
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue
        local repo_name
        repo_name=$(basename "$dir")

        if ! is_git_repo "$dir"; then
            continue  # Skip non-git directories
        fi

        cd "$dir"
        local branch
        branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")
        local status="clean"

        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            status="modified"
        fi

        # Add worktree indicator
        local wt_type
        wt_type=$(get_worktree_type "$dir")
        local wt_suffix=""
        if [ "$wt_type" = "worktree" ]; then
            wt_suffix=" WT"
        fi

        if [ -z "$repo_list" ]; then
            repo_list="$repo_name\t[$branch] ($status)$wt_suffix"
        else
            repo_list="$repo_list"$'\n'"$repo_name\t[$branch] ($status)$wt_suffix"
        fi
    done

    if [ -z "$repo_list" ]; then
        log_error "No git repos found in $REPOS_DIR"
        exit 1
    fi

    log_info "Select repos to fetch and rebase (TAB to select, ENTER to confirm):"
    echo ""

    local selected
    selected=$(echo -e "$repo_list" | fzf --multi \
        --header "üêï Select repos to fetch (TAB=select, Ctrl-A=all, ENTER=confirm)" \
        --preview "echo {} | cut -f2" \
        --preview-window=down:1:wrap \
        --delimiter=$'\t' \
        --with-nth=1 \
        --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
        || true)

    if [ -z "$selected" ]; then
        log_warn "No repos selected"
        exit 0
    fi

    echo ""
    log_info "Fetching and rebasing selected repos..."
    echo ""

    local success=0
    local conflicts=0
    local skipped=0
    local failed=0
    local conflict_repos=()
    local fetched_git_dirs=()  # Track fetched git dirs to avoid redundant fetches

    while IFS= read -r line || [ -n "$line" ]; do
        [ -n "$line" ] || continue
        local repo_name
        repo_name=$(echo "$line" | cut -f1)
        local dir="$REPOS_DIR/$repo_name"

        cd "$dir"

        # Get current branch
        local branch
        branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

        if [ -z "$branch" ]; then
            log_warn "Skipping $repo_name (detached HEAD)"
            ((skipped++))
            continue
        fi

        # Check for uncommitted changes
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            log_warn "Skipping $repo_name (uncommitted changes)"
            ((skipped++))
            continue
        fi

        # Get common git dir (shared by worktrees)
        local git_common_dir
        git_common_dir=$(get_git_common_dir "$dir")

        # Check if we already fetched this git database
        local already_fetched=false
        for fetched_dir in "${fetched_git_dirs[@]:-}"; do
            if [ "$fetched_dir" = "$git_common_dir" ]; then
                already_fetched=true
                break
            fi
        done

        # Fetch from origin (skip if already fetched for this git database)
        echo -n "Fetching $repo_name... "
        if [ "$already_fetched" = true ]; then
            echo -n "(shared fetch) "
        else
            if ! git fetch origin --quiet < /dev/null 2>/dev/null; then
                echo ""
                log_error "Failed to fetch $repo_name"
                ((failed++))
                continue
            fi
            fetched_git_dirs+=("$git_common_dir")
        fi

        # Check if we need to rebase
        local upstream="origin/$branch"
        if ! git rev-parse "$upstream" &>/dev/null; then
            echo "no upstream"
            ((skipped++))
            continue
        fi

        local local_commit
        local_commit=$(git rev-parse HEAD)
        local remote_commit
        remote_commit=$(git rev-parse "$upstream")

        if [ "$local_commit" = "$remote_commit" ]; then
            echo "up to date"
            ((success++))
            continue
        fi

        # Check if we can fast-forward (no local commits ahead)
        local base
        base=$(git merge-base HEAD "$upstream")

        if [ "$base" = "$local_commit" ]; then
            # Fast-forward possible
            if git rebase "$upstream" --quiet < /dev/null 2>/dev/null; then
                echo "rebased (fast-forward)"
                ((success++))
            else
                echo ""
                log_error "Rebase failed for $repo_name"
                git rebase --abort < /dev/null 2>/dev/null || true
                ((failed++))
            fi
        else
            # Need to rebase with local changes
            echo -n "rebasing... "
            if git rebase "$upstream" --quiet < /dev/null 2>/dev/null; then
                echo "done"
                ((success++))
            else
                echo "conflict!"
                git rebase --abort < /dev/null 2>/dev/null || true
                conflict_repos+=("$repo_name")
                ((conflicts++))
            fi
        fi
    done <<< "$selected"

    cd "$REPOS_DIR"

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    log_info "Summary:"
    echo "  ‚úì Success:   $success"
    echo "  ‚ö† Skipped:   $skipped"
    echo "  ‚úó Failed:    $failed"
    echo "  ‚ö° Conflicts: $conflicts"

    if [ ${#conflict_repos[@]} -gt 0 ]; then
        echo ""
        log_warn "Repos with conflicts (need manual rebase):"
        for repo in "${conflict_repos[@]}"; do
            echo "  - $repo"
        done
    fi
}

list_repos() {
    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    log_info "Repos in $REPOS_DIR:"
    echo ""

    local count=0
    local worktree_count=0
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue
        local repo_name
        repo_name=$(basename "$dir")

        if is_git_repo "$dir"; then
            cd "$dir"
            local branch
            branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")
            local status=""

            if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                status=" ${YELLOW}(modified)${NC}"
            fi

            local wt_type
            wt_type=$(get_worktree_type "$dir")
            local wt_indicator=""
            if [ "$wt_type" = "worktree" ]; then
                wt_indicator=" ${YELLOW}(worktree)${NC}"
                ((worktree_count++))
            fi

            echo -e "  $repo_name ${BLUE}[$branch]${NC}$status$wt_indicator"
            ((count++))
        else
            echo -e "  $repo_name ${RED}(not a git repo)${NC}"
        fi
    done

    echo ""
    if [ $worktree_count -gt 0 ]; then
        log_info "Total: $count repos ($worktree_count worktrees)"
    else
        log_info "Total: $count repos"
    fi
}

worktree_command() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list)
            worktree_list
            ;;
        add)
            worktree_add
            ;;
        remove)
            worktree_remove
            ;;
        *)
            log_error "Unknown worktree subcommand: $subcmd"
            echo "Usage: retriever worktree [list|add|remove]"
            exit 1
            ;;
    esac
}

worktree_list() {
    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    log_info "Worktrees in $REPOS_DIR:"
    echo ""

    local found_any=false

    # Find all main repos (not worktrees) and list their worktrees
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue

        # Only process main repos (those with .git directory, not file)
        if [ ! -d "$dir/.git" ]; then
            continue
        fi

        local repo_name
        repo_name=$(basename "$dir")

        cd "$dir"
        local worktrees
        worktrees=$(git worktree list --porcelain 2>/dev/null | grep "^worktree " | sed 's/^worktree //')

        # Count worktrees (first one is the main repo itself)
        local wt_count=0
        while IFS= read -r wt_path; do
            [ -n "$wt_path" ] && ((wt_count++))
        done <<< "$worktrees"

        if [ "$wt_count" -gt 1 ]; then
            found_any=true
            echo -e "${BLUE}$repo_name${NC}"

            while IFS= read -r wt_path; do
                [ -n "$wt_path" ] || continue

                local wt_branch
                wt_branch=$(git -C "$wt_path" symbolic-ref --short HEAD 2>/dev/null || echo "detached")

                local wt_name
                wt_name=$(basename "$wt_path")

                if [ "$wt_path" = "$dir" ] || [ "$wt_path" = "${dir%/}" ]; then
                    echo -e "  ‚îú‚îÄ $wt_name ${BLUE}[$wt_branch]${NC} (main)"
                else
                    echo -e "  ‚îú‚îÄ $wt_name ${BLUE}[$wt_branch]${NC}"
                fi
            done <<< "$worktrees"
            echo ""
        fi
    done

    if [ "$found_any" = false ]; then
        log_info "No worktrees found. Create one with: retriever worktree add"
    fi
}

worktree_add() {
    check_dependencies

    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    # Build list of main repos only (not worktrees)
    local repo_list=""
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue
        [ -d "$dir/.git" ] || continue  # Only main repos

        local repo_name
        repo_name=$(basename "$dir")

        cd "$dir"
        local branch
        branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")

        if [ -z "$repo_list" ]; then
            repo_list="$repo_name\t[$branch]"
        else
            repo_list="$repo_list"$'\n'"$repo_name\t[$branch]"
        fi
    done

    if [ -z "$repo_list" ]; then
        log_error "No repos found in $REPOS_DIR"
        exit 1
    fi

    log_info "Select repo to create worktree for:"
    echo ""

    local selected
    selected=$(echo -e "$repo_list" | fzf \
        --header "üå≥ Select repo for new worktree" \
        --preview "echo {} | cut -f2" \
        --preview-window=down:1:wrap \
        --delimiter=$'\t' \
        --with-nth=1 \
        || true)

    if [ -z "$selected" ]; then
        log_warn "No repo selected"
        exit 0
    fi

    local repo_name
    repo_name=$(echo "$selected" | cut -f1)
    local repo_dir="$REPOS_DIR/$repo_name"

    cd "$repo_dir"

    # Fetch to get latest remote branches
    log_info "Fetching remote branches..."
    git fetch --all --quiet 2>/dev/null || true

    # Build list of remote branches
    local branch_list
    branch_list=$(git branch -r 2>/dev/null | grep -v 'HEAD' | sed 's|^[[:space:]]*origin/||' | sort -u)

    if [ -z "$branch_list" ]; then
        log_error "No remote branches found"
        exit 1
    fi

    echo ""
    log_info "Select branch for worktree (or type to create new):"

    local selected_branch
    selected_branch=$(echo "$branch_list" | fzf \
        --header "üåø Select or type branch name" \
        --print-query \
        || true)

    # fzf --print-query returns query on first line, selection on second
    local query
    query=$(echo "$selected_branch" | head -n1)
    local selection
    selection=$(echo "$selected_branch" | tail -n1)

    local branch_name
    if [ -n "$selection" ] && [ "$selection" != "$query" ]; then
        branch_name="$selection"
    elif [ -n "$query" ]; then
        branch_name="$query"
    else
        log_warn "No branch selected"
        exit 0
    fi

    # Generate default worktree directory name
    local sanitized_branch
    sanitized_branch=$(echo "$branch_name" | sed 's|/|-|g' | sed 's|^feature-||' | sed 's|^bugfix-||' | sed 's|^hotfix-||')
    local default_wt_name="${repo_name}-${sanitized_branch}"

    echo ""
    read -p "Worktree directory name [$default_wt_name]: " wt_name
    wt_name="${wt_name:-$default_wt_name}"

    local wt_path="$REPOS_DIR/$wt_name"

    if [ -e "$wt_path" ]; then
        log_error "Directory already exists: $wt_path"
        exit 1
    fi

    echo ""
    log_info "Creating worktree at $wt_path for branch $branch_name..."

    # Check if branch exists remotely
    if git rev-parse "origin/$branch_name" &>/dev/null; then
        # Branch exists on remote - create worktree tracking it
        if git worktree add "$wt_path" -b "$branch_name" "origin/$branch_name" 2>/dev/null || \
           git worktree add "$wt_path" "$branch_name" 2>/dev/null; then
            log_success "Created worktree: $wt_name [$branch_name]"
        else
            log_error "Failed to create worktree"
            exit 1
        fi
    else
        # New branch - create from current HEAD
        if git worktree add "$wt_path" -b "$branch_name" 2>/dev/null; then
            log_success "Created worktree with new branch: $wt_name [$branch_name]"
        else
            log_error "Failed to create worktree"
            exit 1
        fi
    fi
}

worktree_remove() {
    check_dependencies

    if [ ! -d "$REPOS_DIR" ]; then
        log_error "Repos directory does not exist: $REPOS_DIR"
        exit 1
    fi

    # Build list of all worktrees (excluding main repos)
    local wt_list=""
    for dir in "$REPOS_DIR"/*/; do
        [ -d "$dir" ] || continue
        [ -d "$dir/.git" ] || continue  # Only main repos

        local repo_name
        repo_name=$(basename "$dir")

        cd "$dir"
        local worktrees
        worktrees=$(git worktree list --porcelain 2>/dev/null)

        local current_wt=""
        local current_branch=""

        while IFS= read -r line; do
            if [[ "$line" == "worktree "* ]]; then
                current_wt="${line#worktree }"
            elif [[ "$line" == "branch "* ]]; then
                current_branch="${line#branch refs/heads/}"
            elif [ -z "$line" ] && [ -n "$current_wt" ]; then
                # Skip the main worktree
                if [ "$current_wt" != "$dir" ] && [ "$current_wt" != "${dir%/}" ]; then
                    local wt_name
                    wt_name=$(basename "$current_wt")
                    if [ -z "$wt_list" ]; then
                        wt_list="$wt_name\t[$current_branch] (from $repo_name)"
                    else
                        wt_list="$wt_list"$'\n'"$wt_name\t[$current_branch] (from $repo_name)"
                    fi
                fi
                current_wt=""
                current_branch=""
            fi
        done <<< "$worktrees"

        # Handle last entry
        if [ -n "$current_wt" ] && [ "$current_wt" != "$dir" ] && [ "$current_wt" != "${dir%/}" ]; then
            local wt_name
            wt_name=$(basename "$current_wt")
            if [ -z "$wt_list" ]; then
                wt_list="$wt_name\t[$current_branch] (from $repo_name)"
            else
                wt_list="$wt_list"$'\n'"$wt_name\t[$current_branch] (from $repo_name)"
            fi
        fi
    done

    if [ -z "$wt_list" ]; then
        log_info "No worktrees found to remove"
        exit 0
    fi

    log_info "Select worktrees to remove (TAB to select, ENTER to confirm):"
    echo ""

    local selected
    selected=$(echo -e "$wt_list" | fzf --multi \
        --header "üóëÔ∏è  Select worktrees to remove (TAB=select, ENTER=confirm)" \
        --preview "echo {} | cut -f2" \
        --preview-window=down:1:wrap \
        --delimiter=$'\t' \
        --with-nth=1 \
        --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
        || true)

    if [ -z "$selected" ]; then
        log_warn "No worktrees selected"
        exit 0
    fi

    echo ""
    log_warn "About to remove the following worktrees:"
    while IFS= read -r line || [ -n "$line" ]; do
        [ -n "$line" ] || continue
        local wt_name
        wt_name=$(echo "$line" | cut -f1)
        echo "  - $wt_name"
    done <<< "$selected"

    echo ""
    read -p "Are you sure? (y/N) " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Removal cancelled"
        exit 0
    fi

    local removed=0
    while IFS= read -r line || [ -n "$line" ]; do
        [ -n "$line" ] || continue
        local wt_name
        wt_name=$(echo "$line" | cut -f1)
        local wt_path="$REPOS_DIR/$wt_name"

        # Find the main repo for this worktree
        if [ -f "$wt_path/.git" ]; then
            local git_dir
            git_dir=$(cat "$wt_path/.git" | sed 's/gitdir: //')
            local main_git_dir
            main_git_dir=$(dirname "$(dirname "$git_dir")")

            log_info "Removing worktree $wt_name..."
            if git --git-dir="$main_git_dir" worktree remove "$wt_path" --force < /dev/null 2>/dev/null; then
                log_success "Removed $wt_name"
                ((removed++))
            else
                log_error "Failed to remove $wt_name"
            fi
        else
            log_error "Cannot find git info for $wt_name"
        fi
    done <<< "$selected"

    echo ""
    log_success "Removed $removed worktrees"
}

install_retriever() {
    # Get the directory where this script lives
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Detect shell
    local shell_name
    shell_name=$(basename "$SHELL")
    local rc_file

    case "$shell_name" in
        zsh)
            rc_file="$HOME/.zshrc"
            ;;
        bash)
            if [ -f "$HOME/.bash_profile" ]; then
                rc_file="$HOME/.bash_profile"
            else
                rc_file="$HOME/.bashrc"
            fi
            ;;
        *)
            log_error "Unsupported shell: $shell_name"
            echo "Please manually add this to your shell config:"
            echo "  export PATH=\"\$PATH:$script_dir\""
            exit 1
            ;;
    esac

    # Check if already in PATH
    if echo "$PATH" | tr ':' '\n' | grep -qx "$script_dir"; then
        log_success "Retriever is already in your PATH"
        return 0
    fi

    # Check if export line already exists in rc file
    local export_line="export PATH=\"\$PATH:$script_dir\""
    if grep -qF "$script_dir" "$rc_file" 2>/dev/null; then
        log_success "PATH export already exists in $rc_file"
        log_info "Run 'source $rc_file' or restart your terminal"
        return 0
    fi

    # Add to rc file
    log_info "Adding retriever to PATH in $rc_file..."

    {
        echo ""
        echo "# Retriever - repo fetcher üêï"
        echo "$export_line"
    } >> "$rc_file"

    log_success "Added to $rc_file"
    echo ""
    log_info "Run this to use immediately:"
    echo "  source $rc_file"
    echo ""
    log_info "Or restart your terminal"
}

# Parse arguments
COMMAND=""
WORKTREE_SUBCMD=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--dir)
            REPOS_DIR="$2"
            shift 2
            ;;
        clone|fetch|list|install|help)
            COMMAND="$1"
            shift
            ;;
        worktree)
            COMMAND="worktree"
            shift
            WORKTREE_SUBCMD="${1:-list}"
            [ $# -gt 0 ] && shift
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Default to help if no command
if [ -z "$COMMAND" ]; then
    usage
    exit 0
fi

# Run command
case $COMMAND in
    clone)
        clone_repos
        ;;
    fetch)
        fetch_repos
        ;;
    list)
        list_repos
        ;;
    worktree)
        worktree_command "$WORKTREE_SUBCMD"
        ;;
    install)
        install_retriever
        ;;
    help)
        usage
        ;;
esac
